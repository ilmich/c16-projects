#include <string.h>
#include <conio.h>
#include <stdlib.h>

#pragma bss-name (push,"ZEROPAGE")
#pragma data-name(push,"ZEROPAGE")
#pragma bss-name (pop)
#pragma data-name(pop)

/*	chip8 memory structured access
	
	0 --> video memory
	256 --> 16 sprites for chars (80 bytes)
	336 --> 16 register
	352 --> i register
	354 --> stack pointer
	355 --> program counter
	357 --> stack pointer (depth 32)
	512 --> start program
*/

struct chip8 {
	unsigned char video[256];
	unsigned char char_sprites[16 * 5];
	unsigned char v[16];
	unsigned int i;
	unsigned char sp;
	unsigned int pc;
	unsigned int stack[32];
	unsigned short eof;
	unsigned char delay_timer;
	unsigned char sound_timer;
	unsigned char key_pressed;
	unsigned char offset[86];
	unsigned char code[3584];
};

/*
	chip8 memory raw access
*/
struct chip8_raw {
	unsigned char memory[4096];
};

struct char_screen {
	unsigned char data[1024];
};

#define MAX_PROGRAM_LENGTH 3584
#define SCREEN ( *(struct char_screen*) 0x0c00 )
#define CHIP8 ( *(struct chip8*) 0x3000 )
#define CHIP8_RAW ( *(struct chip8_raw*) 0x3000 )

unsigned char lowres_char[] = {
	0x20, 0x6C, 0x7B, 0x62,
	0x7C, 0xE1, 0xFF, 0xFE,
	0x7E, 0x7F, 0x61, 0xFC,
	0xE2, 0xFB, 0xEC, 0xA0
};

unsigned char chip8_alphanum[] = { 0xF0, 0x90, 0x90, 0x90, 0xF0,	// sprite for char '0'
	0x20, 0x60, 0x20, 0x20, 0x70,	// sprite for char '1'
	0xF0, 0x10, 0xF0, 0x80, 0xF0,	// sprite for char '2'
	0xF0, 0x10, 0xF0, 0x10, 0xF0,	// sprite for char '3'
	0x90, 0x90, 0xF0, 0x10, 0x10,	// sprite for char '4'
	0xF0, 0x80, 0xF0, 0x10, 0xF0,	// sprite for char '5'
	0xF0, 0x80, 0xF0, 0x90, 0xF0,	// sprite for char '6'
	0xF0, 0x10, 0x20, 0x40, 0x40,	// sprite for char '7'
	0xF0, 0x90, 0xF0, 0x90, 0xF0,	// sprite for char '8'
	0xF0, 0x90, 0xF0, 0x10, 0xF0,	// sprite for char '9'
	0xF0, 0x90, 0xF0, 0x90, 0x90,	// sprite for char 'A'
	0xE0, 0x90, 0xE0, 0x90, 0xE0,	// sprite for char 'B'
	0xF0, 0x80, 0x80, 0x80, 0xF0,	// sprite for char 'C'
	0xE0, 0x90, 0x90, 0x90, 0xE0,	// sprite for char 'D'
	0xF0, 0x80, 0xF0, 0x80, 0xF0,	// sprite for char 'E'
	0xF0, 0x80, 0xF0, 0x80, 0x80,	// sprite for char 'F'
};

/**
	simple 8bit random number generator
*/
unsigned char rand_8bit(void)
{

	unsigned char rand8bit;

	asm("lda %v", rand8bit);
	asm("beq doEor");
	asm("asl");
	asm("beq noEor");
	asm("bcc noEor");
	asm("doEor:    eor #$1d");
	asm("noEor:  sta %v", rand8bit);

	return rand8bit;
}

/*
unsigned char sample_ch8[] = {
  0x60, 0x00, 
  0x61, 0x00, 
  0xa2, 0x22, 
  0xc2, 0x01, 
  0x32, 0x01, 
  0xa2, 0x1e,
  0xd0, 0x14, 
  0x70, 0x04, 
  0x30, 0x40, 
  0x12, 0x04, 
  0x60, 0x00, 
  0x71, 0x04,
  0x31, 0x20, 
  0x12, 0x04, 
  0x12, 0x1c, 
  0x80, 0x40, 
  0x20, 0x10, 
  0x20, 0x40,
  0x80, 0x10
};
unsigned short sample_ch8_len = 38;

unsigned char Particle_Demo__zeroZshadow__2008__ch8[] = {
  0xa3, 0x21, 0x60, 0x00, 0x61, 0x00, 0x62, 0x08, 0xd0, 0x15, 0xf2, 0x1e,
  0x80, 0x24, 0xd0, 0x15, 0xf2, 0x1e, 0x80, 0x24, 0xd0, 0x15, 0xf2, 0x1e,
  0x80, 0x24, 0xd0, 0x15, 0xf2, 0x1e, 0x80, 0x24, 0xd0, 0x15, 0xf2, 0x1e,
  0x80, 0x24, 0xd0, 0x15, 0xf2, 0x1e, 0x80, 0x24, 0xd0, 0x15, 0xf2, 0x1e,
  0x80, 0x24, 0xd0, 0x15, 0x66, 0x05, 0x67, 0x02, 0x6a, 0x00, 0x12, 0xb8,
  0x6b, 0x00, 0x6c, 0x00, 0xa2, 0xd8, 0xfb, 0x1e, 0xf3, 0x65, 0x22, 0xce,
  0x22, 0x5c, 0x12, 0x62, 0x22, 0xce, 0x22, 0x5c, 0x7b, 0x04, 0x7c, 0x01,
  0x5c, 0x60, 0x12, 0x40, 0x12, 0x3c, 0x12, 0x00, 0xa3, 0x20, 0xde, 0xd1,
  0x00, 0xee, 0xa2, 0xd8, 0xfb, 0x1e, 0xf3, 0x65, 0x80, 0x24, 0x81, 0x34,
  0x8e, 0x00, 0x8d, 0x10, 0x8e, 0xe6, 0x8d, 0xd6, 0x84, 0xe0, 0x65, 0xc2,
  0x84, 0x54, 0x4f, 0x01, 0x12, 0x92, 0x4d, 0x00, 0x63, 0x01, 0x84, 0xd0,
  0x65, 0xe1, 0x84, 0x54, 0x4f, 0x01, 0x12, 0x92, 0x33, 0x02, 0x73, 0x01,
  0x12, 0x94, 0x22, 0x9c, 0xa2, 0xd8, 0xfb, 0x1e, 0xf3, 0x55, 0x12, 0x4c,
  0xa3, 0x00, 0xfa, 0x1e, 0xf0, 0x65, 0x82, 0x00, 0x7a, 0x01, 0x64, 0x1f,
  0x8a, 0x42, 0x60, 0x20, 0x61, 0x1e, 0x80, 0x0e, 0x81, 0x1e, 0xc3, 0x03,
  0x73, 0xf8, 0x00, 0xee, 0x6b, 0x00, 0x6c, 0x00, 0x22, 0x9c, 0xa2, 0xd8,
  0xfb, 0x1e, 0xf3, 0x55, 0x7b, 0x04, 0x7c, 0x01, 0x5c, 0x60, 0x12, 0xbc,
  0x12, 0x3c, 0x8e, 0x00, 0x8d, 0x10, 0x8e, 0xe6, 0x8d, 0xd6, 0x00, 0xee,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xf8, 0xfa, 0xf9, 0xfe, 0xfb, 0xfc, 0xfd, 0xff,
  0x02, 0x01, 0x03, 0x05, 0x04, 0x06, 0x07, 0x08, 0x06, 0x07, 0x04, 0x05,
  0x03, 0x01, 0x02, 0xfe, 0xff, 0xfc, 0xfb, 0xfd, 0xfa, 0xf9, 0xf8, 0xfa,
  0x80, 0xf7, 0x06, 0x77, 0x06, 0x36, 0x00, 0x00, 0x00, 0xc7, 0x6c, 0xcf,
  0x0c, 0x0c, 0x00, 0x00, 0x00, 0x9f, 0xd9, 0xdf, 0xd9, 0xd9, 0x00, 0x00,
  0x00, 0x3f, 0x8c, 0x0c, 0x8c, 0x8c, 0x00, 0x00, 0x00, 0x67, 0x6c, 0x6c,
  0x6c, 0x67, 0x00, 0x00, 0x00, 0xb0, 0x30, 0x30, 0x30, 0xbe, 0x00, 0x00,
  0x00, 0xf9, 0xc3, 0xf1, 0xc0, 0xfb, 0x00, 0x00, 0x00, 0xef, 0x00, 0xce,
  0x60, 0xcc, 0x00, 0x00, 0x00
};
unsigned int Particle_Demo__zeroZshadow__2008__ch8_len = 353;
*/
unsigned char Airplane_ch8[] = {
	0x6a, 0x00, 0x6b, 0x04, 0x6c, 0x01, 0x6d, 0x00, 0x6e, 0x02, 0x23, 0x26,
	0x23, 0x20, 0x60, 0x30, 0x61, 0x01, 0xf0, 0x15, 0xf0, 0x07, 0xf1, 0x18,
	0x30, 0x00, 0x12, 0x14, 0x22, 0x42, 0x23, 0x20, 0x7d, 0x01, 0x23, 0x20,
	0x60, 0x08, 0xe0, 0xa1, 0x23, 0x0a, 0x4a, 0x00, 0x12, 0x3e, 0xa3, 0x62,
	0xd8, 0x91, 0x79, 0x01, 0xd8, 0x91, 0x4f, 0x01, 0x12, 0xf4, 0x49, 0x18,
	0x12, 0xe4, 0x22, 0xb2, 0x12, 0x1e, 0x4c, 0x01, 0x22, 0x6c, 0x4c, 0x02,
	0x22, 0x7a, 0x4c, 0x03, 0x22, 0x88, 0x4c, 0x04, 0x22, 0x96, 0x4c, 0x05,
	0x22, 0xa4, 0xa3, 0x59, 0xd6, 0x72, 0x44, 0x00, 0x00, 0xee, 0xa3, 0x57,
	0xd4, 0x52, 0x42, 0x00, 0x00, 0xee, 0xa3, 0x5b, 0xd2, 0x32, 0x00, 0xee,
	0x66, 0x28, 0x67, 0x09, 0x64, 0x00, 0x65, 0x00, 0x62, 0x00, 0x63, 0x00,
	0x00, 0xee, 0x66, 0x28, 0x67, 0x0e, 0x64, 0x28, 0x65, 0x14, 0x62, 0x00,
	0x63, 0x00, 0x00, 0xee, 0x66, 0x28, 0x67, 0x07, 0x64, 0x28, 0x65, 0x0c,
	0x62, 0x16, 0x63, 0x11, 0x00, 0xee, 0x66, 0x28, 0x67, 0x07, 0x64, 0x28,
	0x65, 0x0e, 0x62, 0x16, 0x63, 0x14, 0x00, 0xee, 0x66, 0x28, 0x67, 0x05,
	0x64, 0x28, 0x65, 0x10, 0x62, 0x16, 0x63, 0x0b, 0x00, 0xee, 0xa3, 0x59,
	0xd6, 0x72, 0x76, 0xfe, 0xd6, 0x72, 0x44, 0x00, 0x00, 0xee, 0xa3, 0x57,
	0xd4, 0x52, 0x74, 0x02, 0x44, 0x44, 0x74, 0xc0, 0xd4, 0x52, 0x42, 0x00,
	0x00, 0xee, 0xa3, 0x5b, 0xd2, 0x32, 0x72, 0x02, 0x4c, 0x04, 0x72, 0x02,
	0x4c, 0x05, 0x72, 0x02, 0x42, 0x44, 0x72, 0xc0, 0xd2, 0x32, 0x00, 0xee,
	0x7c, 0x01, 0x6d, 0x00, 0x6e, 0x02, 0x00, 0xe0, 0x4c, 0x06, 0x6c, 0x01,
	0x6a, 0x00, 0x12, 0x0a, 0x60, 0x06, 0xf0, 0x18, 0x7b, 0xff, 0x4b, 0x00,
	0x13, 0x08, 0x6d, 0x00, 0x6e, 0x02, 0x00, 0xe0, 0x6a, 0x00, 0x12, 0x0a,
	0x13, 0x08, 0x4a, 0x01, 0x00, 0xee, 0x60, 0x02, 0xf0, 0x18, 0x6a, 0x01,
	0x88, 0xd0, 0x78, 0x01, 0x89, 0xe0, 0x79, 0x01, 0xd8, 0x91, 0x00, 0xee,
	0xa3, 0x54, 0xdd, 0xe2, 0x00, 0xee, 0x64, 0x19, 0x63, 0x00, 0xa3, 0x56,
	0xd3, 0x41, 0x73, 0x08, 0x33, 0x40, 0x13, 0x2c, 0x63, 0x1e, 0x64, 0x1b,
	0xfc, 0x29, 0xd3, 0x45, 0x4b, 0x04, 0xa3, 0x5f, 0x4b, 0x03, 0xa3, 0x60,
	0x4b, 0x02, 0xa3, 0x61, 0x4b, 0x01, 0xa3, 0x62, 0x63, 0x01, 0x74, 0x02,
	0xd3, 0x41, 0x00, 0xee, 0x80, 0xf8, 0xff, 0x80, 0xe0, 0x10, 0x70, 0x88,
	0xee, 0x11, 0x77, 0xaa, 0xa8, 0xa0, 0x80, 0x00
};

unsigned int Airplane_ch8_len = 356;

void paint_screen()
{
	unsigned char y = 0;
	unsigned char x = 0;
	unsigned char pos, pos2;
	unsigned char pointer = 0;
	unsigned short screen_pointer;
	unsigned char char4byte[4];	// 4 chars for 1 byte

	screen_pointer = 84;
	pointer = 0;

	do {
		pos = CHIP8.video[pointer];
		pos2 = CHIP8.video[pointer + 8];

		char4byte[3] = (pos2 & 0x03);
		char4byte[3] = char4byte[3] + ((pos << 2) & 12);

		pos2 = pos2 >> 2;
		char4byte[2] = (pos2 & 0x03);
		char4byte[2] = char4byte[2] + (pos & 12);

		pos = pos >> 2;
		pos2 = pos2 >> 2;
		char4byte[1] = (pos2 & 0x03);
		char4byte[1] = char4byte[1] + (pos & 12);

		pos = pos >> 2;
		pos2 = pos2 >> 2;
		char4byte[0] = (pos2 & 0x03);
		char4byte[0] = char4byte[0] + (pos & 12);

		SCREEN.data[screen_pointer] = lowres_char[char4byte[0]];
		++screen_pointer;
		SCREEN.data[screen_pointer] = lowres_char[char4byte[1]];
		++screen_pointer;
		SCREEN.data[screen_pointer] = lowres_char[char4byte[2]];
		++screen_pointer;
		SCREEN.data[screen_pointer] = lowres_char[char4byte[3]];
		++screen_pointer;
		++pointer;
		if (pointer % 8 == 0) {
			screen_pointer += 8;
			pointer += 8;
			++x;
		}
	} while (x < 16);
}

void load_program(unsigned char data[], unsigned short lenght)
{
	unsigned int y = 0;
	unsigned char x = 0;

	do {			// reset registers
		CHIP8.v[x] = 0;
		++x;
	} while (x < 16);
	CHIP8.i = 0;

	x = 0;
	do {			// reset stack
		CHIP8.stack[x] = 0;
		++x;
	} while (x < 32);
	CHIP8.sp = 32;

	x = 0;
	do {			// reset video memory
		CHIP8.video[x] = 0x0;
		++x;
	} while (x != 0);

	do {			// load code
		CHIP8.code[y] = data[y];
		++y;
	} while (y < lenght);
	CHIP8.pc = 512;
	CHIP8.eof = 512 + lenght;

	x = 0;
	do {			// load character sprites
		CHIP8.char_sprites[x] = chip8_alphanum[x];
		++x;
	} while (x < 80);

	CHIP8.delay_timer = 0;
	CHIP8.sound_timer = 0;

}

unsigned char scancode_to_chip8(unsigned char wait)
{
	unsigned char x;

	do {
		cbm_k_scnkey();
		x = cbm_k_getin();
	} while (wait && x == 0);

	switch (x) {
	case '1':
		x = 1;
		break;
	case '2':
		x = 2;
		break;
	case '3':
		x = 3;
		break;
	case '4':
		x = 0x0c;
		break;
	case 'q':
		x = 4;
		break;
	case 'w':
		x = 5;
		break;
	case 'e':
		x = 6;
		break;
	case 'r':
		x = 0x0d;
		break;
	case 'a':
		x = 7;
		break;
	case 's':
		x = 8;
		break;
	case 'd':
		x = 9;
		break;
	case 'f':
		x = 0x0e;
		break;
	case 'z':
		x = 0x0a;
		break;
	case 'x':
		x = 0x0;
		break;
	case 'c':
		x = 0x0b;
		break;
	case 'v':
		x = 0x0f;
		break;
	default:
		x = 99;
		break;
	};

	return x;
}

unsigned char frames = 0;

int runOpcode(void)
{
	unsigned char x, vx, vy, nibble, offset_c1, offset_c2, d1, c1, d2, c2,
	    y;
	unsigned char word_hi, word_lo;
	unsigned short addr, pointer_d, overflow;

	word_hi = CHIP8_RAW.memory[CHIP8.pc];
	++CHIP8.pc;
	word_lo = CHIP8_RAW.memory[CHIP8.pc];
	++CHIP8.pc;

	vx = (word_hi & 0x0f);
	vy = (word_lo >> 4);

	switch (word_hi & 0xf0) {
	case 0x00:
		switch (word_lo) {
		case 0xee:
			CHIP8.pc = CHIP8.stack[CHIP8.sp];
			++CHIP8.sp;
			break;
		case 0xe0:
			x = 0;
			do {
				CHIP8.video[x] = 0x0;
				++x;
			} while (x != 0);
			break;
		}
		break;
	case 0x10:
		addr = (((word_hi & 0x0f) * 256) + word_lo);
		CHIP8.pc = addr;
		break;
	case 0x20:
		addr = (((word_hi & 0x0f) * 256) + word_lo);
		if (CHIP8.sp) {
			--CHIP8.sp;
			CHIP8.stack[CHIP8.sp] = CHIP8.pc;
			CHIP8.pc = addr;
		}
		break;
	case 0x30:
		if (CHIP8.v[vx] == word_lo) {
			CHIP8.pc += 2;
		}
		break;
	case 0x40:
		if (CHIP8.v[vx] != word_lo) {
			CHIP8.pc += 2;
		}
		break;
	case 0x50:
		if (CHIP8.v[vx] == CHIP8.v[vy]) {
			CHIP8.pc += 2;
		}
		break;
	case 0x60:
		CHIP8.v[vx] = word_lo;
		break;
	case 0x70:
		CHIP8.v[vx] = CHIP8.v[vx] + word_lo;
		break;
	case 0x80:
		switch (word_lo & 0x0f) {
		case 0x0:
			CHIP8.v[vx] = CHIP8.v[vy];
			break;
		case 0x1:
			CHIP8.v[vx] = CHIP8.v[vx] | CHIP8.v[vy];
			break;
		case 0x02:
			CHIP8.v[vx] = CHIP8.v[vx] & CHIP8.v[vy];
			break;
		case 0x3:
			CHIP8.v[vx] = CHIP8.v[vx] ^ CHIP8.v[vy];
			break;
		case 0x4:
			overflow = CHIP8.v[vx] + CHIP8.v[vy];
			if (overflow > 255) {
				CHIP8.v[15] = 1;
			} else {
				CHIP8.v[15] = 0;
			}
			CHIP8.v[vx] = overflow;
			break;
		case 0x5:
			CHIP8.v[15] = (CHIP8.v[vx] > CHIP8.v[vy]) ? 1 : 0;
			CHIP8.v[vx] = CHIP8.v[vx] - CHIP8.v[vy];
			break;
		case 0x6:
			CHIP8.v[15] = CHIP8.v[vx] & 0x01;
			CHIP8.v[vx] = CHIP8.v[vx] >> 1;
			break;
		case 0x7:
			CHIP8.v[15] = (CHIP8.v[vy] > CHIP8.v[vx]) ? 1 : 0;
			CHIP8.v[vx] = CHIP8.v[vy] - CHIP8.v[vx];
			break;
		case 0xE:
			CHIP8.v[15] = CHIP8.v[vx] >> 7;
			CHIP8.v[vx] = CHIP8.v[vx] << 1;
			break;
		default:
			cprintf("unknow 80 0x%x%x|", word_hi, word_lo);
			break;
		}
		break;
	case 0x90:
		if (CHIP8.v[vx] != CHIP8.v[vy]) {
			CHIP8.pc += 2;
		}
		break;
	case 0xA0:
		addr = (((word_hi & 0x0f) * 256) + word_lo);
		CHIP8.i = addr;
		break;
	case 0xC0:
		CHIP8.v[vx] = rand_8bit() & word_lo;
		break;
	case 0xD0:
		nibble = word_lo & 0x0f;
		offset_c2 = 0;
		d2 = 0;
		if (CHIP8.v[vx] < 64) {
			offset_c1 = (CHIP8.v[vx] & 7);
			if (offset_c1) {
				offset_c2 = 8 - offset_c1;
			}
			x = 0;
			y = 0;
			pointer_d = (CHIP8.v[vy] * 8) + (CHIP8.v[vx] / 8);
			addr = CHIP8.i;
			CHIP8.v[0x0f] = 0;
			do {
				d1 = (CHIP8_RAW.memory[addr + y] >> offset_c1);
				if (offset_c2) {
					d2 = (CHIP8_RAW.memory[addr + y] <<
					      offset_c2);
				}

				c1 = CHIP8.video[pointer_d];
				CHIP8.video[pointer_d] = c1 ^ d1;
				if (CHIP8.video[pointer_d] != (c1 | d1)) {
					CHIP8.v[0x0f] = 1;
				}
				if (d2) {
					c2 = CHIP8.video[pointer_d + 1];
					CHIP8.video[pointer_d + 1] = c2 ^ d2;
					if (CHIP8.video[pointer_d + 1] !=
					    (c2 | d2)) {
						CHIP8.v[0x0f] = 1;
					}
				}
				++x;
				++y;
				pointer_d += 8;
			} while (x < nibble);
		}
		return 1;
		break;
	case 0xE0:
		switch (word_lo & 0xff) {
		case 0x9e:
			if (CHIP8.key_pressed == CHIP8.v[vx]) {
				CHIP8.pc += 2;
			}
			break;
		case 0xa1:
			if (CHIP8.key_pressed != CHIP8.v[vx]) {
				CHIP8.pc += 2;
			}
			break;
		}
		break;
	case 0xF0:
		switch (word_lo & 0xff) {
		case 0x07:
			CHIP8.v[vx] = CHIP8.delay_timer;
			break;
		case 0x1e:
			CHIP8.i = CHIP8.i + CHIP8.v[vx];
			break;
		case 0x15:
			CHIP8.delay_timer = CHIP8.v[vx];
			break;
		case 0x18:
			CHIP8.sound_timer = CHIP8.v[vx];
			break;
		case 0x29:
			CHIP8.i = 256 + (CHIP8.v[vx] * 5);
			break;
		case 0x55:
			x = 0;
			do {
				CHIP8_RAW.memory[CHIP8.i] = CHIP8.v[x];
				++CHIP8.i;
				++x;
			} while (x <= vx);
			break;
		case 0x65:
			x = 0;
			do {
				CHIP8.v[x] = CHIP8_RAW.memory[CHIP8.i];
				++CHIP8.i;
				++x;
			} while (x <= vx);
			break;
		case 0x0A:
			CHIP8.v[vx] = scancode_to_chip8(1);
			break;
		default:
			cprintf("unknow f0 0x%x --> 0x%x%x|", CHIP8.pc, word_hi,
				word_lo);
			break;
		}
		break;
	default:
		cprintf("unknow 0x%x%x|", word_hi, word_lo);
		break;
	}

	return 0;

}

void raster_routine(void)
{
	asm("lda $ff09");
	asm("sta $ff09");
	if (CHIP8.delay_timer > 0) {
		--CHIP8.delay_timer;
	}
	CHIP8.key_pressed = scancode_to_chip8(0);
	++frames;
	asm("jmp $fcbe");
}

void raster_irq(void)
{
	asm("sei");
	asm("lda #<%v", raster_routine);
	asm("sta $314");
	asm("lda #>%v", raster_routine);
	asm("sta $315");

	asm("lda #$02");
	asm("sta $ff0a");

	asm("lda #64");
	asm("sta $ff0b");

	asm("lda $ff09");
	asm("sta $ff09");
	asm("cli");
	asm("rts");
}

int main(void)
{
	unsigned char x = 0;
	unsigned short eof = 512 + 10;
	clrscr();
	load_program(Airplane_ch8, Airplane_ch8_len);
	raster_irq();
	do {
		if (runOpcode()) {
			paint_screen();
		}
	} while (CHIP8.pc < CHIP8.eof);

	return 0;
}
